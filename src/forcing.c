#include "pihm.h"

void ApplyForcing (forc_struct *forc, int t)
{
    int             k;

    /* Boundary conditions */
    if (forc->nbc > 0)
    {
        for (k = 0; k < forc->nbc; k++)
        {
            IntrplForcing (forc->bc[k], t, 1);
        }
    }

    /* Meteorological forcing */
    for (k = 0; k < forc->nmeteo; k++)
    {
        IntrplForcing (forc->meteo[k], t, NUM_METEO_VAR);
    }

    /* LAI forcing */
    if (forc->nlai > 0)
    {
        for (k = 0; k < forc->nlai; k++)
        {
            IntrplForcing (forc->lai[k], t, 1);
        }
    }

    /* River boundary condition */
    if (forc->nriverbc > 0)
    {
        for (k = 0; k < forc->nriverbc; k++)
        {
            IntrplForcing (forc->riverbc[k], t, 1);
        }
    }

#ifdef _NOAH_
    if (forc->nrad > 0)
    {
        for (k = 0; k < forc->nrad; k++)
        {
            IntrplForcing (forc->rad[k], t, 2);
        }
    }
#endif
}

void IntrplForcing (tsdata_struct ts, int t, int nvrbl)
{
    int             j;
    int             first, middle, last;

    if (t <= ts.ftime[0])
    {
        for (j = 0; j < nvrbl; j++)
        {
            ts.value[j] = ts.data[0][j];
        }
    }
    else if (t >= ts.ftime[ts.length - 1])
    {
        for (j = 0; j < nvrbl; j++)
        {
            ts.value[j] = ts.data[ts.length - 1][j];
        }
    }
    else
    {
        first = 1;
        last = ts.length - 1;

        while (first <= last)
        {
            middle = (first + last) / 2;
            if (t >= ts.ftime[middle - 1] && t <= ts.ftime[middle])
            {
                for (j = 0; j < nvrbl; j++)
                {
                    ts.value[j] =
                        ((double)(ts.ftime[middle] - t) * ts.data[middle -
                            1][j] + (double)(t - ts.ftime[middle -
                                1]) * ts.data[middle][j]) /
                        (double)(ts.ftime[middle] - ts.ftime[middle - 1]);
                }
                break;
            }
            else if (ts.ftime[middle] > t)
            {
                last = middle - 1;
            }
            else
            {
                first = middle + 1;
            }
        }
    }
}

double MonthlyLAI (int t, int lc_type)
{
    /*
     * Monly LAI data come from WRF MPTABLE.TBL for Noah MODIS land
     * cover categories
     */
    time_t          rawtime;
    struct tm      *timestamp;

    double          lai_tbl[20][12] = {
        {4.0, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0},
        {4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 4.5},
        {0.0, 0.0, 0.0, 0.6, 1.2, 2.0, 2.6, 1.7, 1.0, 0.5, 0.2, 0.0},
        {0.0, 0.0, 0.3, 1.2, 3.0, 4.7, 4.5, 3.4, 1.2, 0.3, 0.0, 0.0},
        {2.0, 2.0, 2.2, 2.6, 3.5, 4.3, 4.3, 3.7, 2.6, 2.2, 2.0, 2.0},
        {0.0, 0.0, 0.3, 0.9, 2.2, 3.5, 3.5, 2.5, 0.9, 0.3, 0.0, 0.0},
        {0.0, 0.0, 0.2, 0.6, 1.5, 2.3, 2.3, 1.7, 0.6, 0.2, 0.0, 0.0},
        {0.2, 0.2, 0.4, 1.0, 2.4, 4.1, 4.1, 2.7, 1.0, 0.4, 0.2, 0.2},
        {0.3, 0.3, 0.5, 0.8, 1.8, 3.6, 3.8, 2.1, 0.9, 0.5, 0.3, 0.3},
        {0.4, 0.5, 0.6, 0.7, 1.2, 3.0, 3.5, 1.5, 0.7, 0.6, 0.5, 0.4},
        {0.2, 0.3, 0.3, 0.5, 1.5, 2.9, 3.5, 2.7, 1.2, 0.3, 0.3, 0.2},
        {0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 3.0, 3.0, 1.5, 0.0, 0.0, 0.0},
        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
        {0.2, 0.3, 0.3, 0.4, 1.1, 2.5, 3.2, 2.2, 1.1, 0.3, 0.3, 0.2},
        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
        {1.0, 1.0, 1.1, 1.3, 1.7, 2.1, 2.1, 1.8, 1.3, 1.1, 1.0, 1.0},
        {0.6, 0.6, 0.7, 0.8, 1.2, 1.8, 1.8, 1.3, 0.8, 0.7, 0.6, 0.6},
        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}
    };

    rawtime = t;
    timestamp = gmtime (&rawtime);

    return (lai_tbl[lc_type - 1][timestamp->tm_mon]);
}

double MonthlyRL (int t, int lc_type)
{
    /*
     * Monly roughness length data are calculated using monthly LAI
     * data above with max/min LAI and max/min roughness length data
     * in the vegprmt.tbl
     */
    time_t          rawtime;
    struct tm      *timestamp;

    double          rl_tbl[20][12] = {
        {0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500},
        {0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500},
        {0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500},
        {0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500},
        {0.200, 0.200, 0.200, 0.200, 0.278, 0.367, 0.367, 0.300, 0.200, 0.200, 0.200, 0.200},
        {0.010, 0.010, 0.010, 0.015, 0.032, 0.048, 0.048, 0.035, 0.015, 0.010, 0.010, 0.010},
        {0.010, 0.010, 0.010, 0.010, 0.033, 0.053, 0.053, 0.038, 0.010, 0.010, 0.010, 0.010},
        {0.010, 0.010, 0.010, 0.016, 0.034, 0.050, 0.050, 0.038, 0.016, 0.010, 0.010, 0.010},
        {0.150, 0.150, 0.150, 0.150, 0.150, 0.150, 0.150, 0.150, 0.150, 0.150, 0.150, 0.150},
        {0.100, 0.100, 0.101, 0.102, 0.106, 0.120, 0.120, 0.108, 0.102, 0.101, 0.100, 0.100},
        {0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000},
        {0.050, 0.050, 0.050, 0.050, 0.050, 0.061, 0.085, 0.085, 0.050, 0.050, 0.050, 0.050},
        {0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500},
        {0.050, 0.050, 0.050, 0.050, 0.050, 0.059, 0.091, 0.050, 0.050, 0.050, 0.050, 0.050},
        {0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001},
        {0.010, 0.010, 0.010, 0.010, 0.010, 0.010, 0.010, 0.010, 0.010, 0.010, 0.010, 0.010},
        {0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001},
        {0.300, 0.300, 0.300, 0.300, 0.300, 0.300, 0.300, 0.300, 0.300, 0.300, 0.300, 0.300},
        {0.150, 0.150, 0.150, 0.150, 0.150, 0.150, 0.150, 0.150, 0.150, 0.150, 0.150, 0.150},
        {0.050, 0.050, 0.050, 0.050, 0.050, 0.050, 0.050, 0.050, 0.050, 0.050, 0.050, 0.050},
    };


    rawtime = t;
    timestamp = gmtime (&rawtime);

    return (rl_tbl[lc_type - 1][timestamp->tm_mon]);
}

double MonthlyMF (int t)
{
    time_t          rawtime;
    struct tm      *timestamp;

    double          mf_tbl[12] =
        { 0.001308019, 0.001633298, 0.002131198, 0.002632776, 0.003031171,
        0.003197325, 0.003095839, 0.002745240, 0.002260213, 0.001759481,
        0.001373646, 0.001202083
    };

    rawtime = t;
    timestamp = gmtime (&rawtime);

    return (mf_tbl[timestamp->tm_mon]);
}
